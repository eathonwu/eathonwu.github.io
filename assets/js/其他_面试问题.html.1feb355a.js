"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7260],{2342:(a,e,n)=>{n.r(e),n.d(e,{comp:()=>l,data:()=>r});var i=n(641);const s={},l=(0,n(6262).A)(s,[["render",function(a,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h1 id="华盛通2023-07-07-一面" tabindex="-1"><a class="header-anchor" href="#华盛通2023-07-07-一面"><span>华盛通2023-07-07 一面</span></a></h1><h2 id="spring中的设计模式" tabindex="-1"><a class="header-anchor" href="#spring中的设计模式"><span>spring中的设计模式</span></a></h2><h2 id="aop机制" tabindex="-1"><a class="header-anchor" href="#aop机制"><span>Aop机制</span></a></h2><p>面向切面变成, 基于jdk 动态代理和cglib动态代理实现, 可以为方法指定对应的切面 ,从而动态扩展方法功能 , 比如为远程方法调用增加日志、trace.等</p><p>jdk动态代理:运行时动态代理技术, 可以实现对接口的动态代理, 实现对象的invoactionhandler 来扩展原有类中方法的功能, 底层使用代理模式,重新生成一个代理类, 在调用方法之前或者之后 加载invocationhandler里面的扩展方法,只能对方法进行动态代理,</p><p>cglib: 编译时字节码增强技术, 可以对字段、类、方法进行字节码增强</p><p>spring -aop: 对jdk动态代理、cglib进行包装, 常用的注解, @Aspect 定义切面 , @PointCut 定义切人点 ,切入点即拦截的方法位置 , @Around 、@Before @After 定义Advice 通知, 比如加日志、监控、上报指标等</p><h2 id="kafka消息积压如何处理-加消费者后rebalance如何解决分区重分配问题" tabindex="-1"><a class="header-anchor" href="#kafka消息积压如何处理-加消费者后rebalance如何解决分区重分配问题"><span>kafka消息积压如何处理, 加消费者后rebalance如何解决分区重分配问题</span></a></h2><p>rebalance 无法避免</p><h2 id="redis节点挂掉如何处理" tabindex="-1"><a class="header-anchor" href="#redis节点挂掉如何处理"><span>redis节点挂掉如何处理</span></a></h2><p>ping消息获取节点信息:</p><p>投票过程是集群中所有master参与,如果半数以上master节点与master节点通信超时(cluster-node-timeout),认为当前master节点挂掉。</p><p>如果无对应的salve节点, 集群直接不可用</p><p>slave 节点发小master节点挂掉后,开始raft 选举, offset 最大的节点优先选举, offset比较小的延迟选举</p><p>扩展信息</p><p>kafka</p><p>​ leader follower 挂掉后也是类似的原则, 由controller节点 , 从AR 副本 (ISR) 中选取一个副本作为leader 副本</p><p>elasticesarch (bully算法)</p><p>master节点选举: activeMaster列表是其它节点认为的当前集群的Master节点列表，如果activeMasters列表不为空，elasticsearch会优先从activeMasters列表中选举，也就是对应着流程图中的蓝色框，选举的算法是Bully算法，笔者在前文中详细介绍了Bully算法，Bully算法会涉及到优先级比较， 在activeMasters列表优先级比较的时候，如果节点有成为master的资格，那么优先级比较高，如果activeMaster列表有多个节点具有master资格，那么选择id最小的节点</p><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><p>线程数量如何规划</p><p>cpu类型的 N+1, IO密集型2N</p><h2 id="arraylist-、linklist插入数据时间复杂度、空间复杂度" tabindex="-1"><a class="header-anchor" href="#arraylist-、linklist插入数据时间复杂度、空间复杂度"><span>arraylist 、linklist插入数据时间复杂度、空间复杂度</span></a></h2><h2 id="clickhouse物化视图实现-是否存在一致性问题" tabindex="-1"><a class="header-anchor" href="#clickhouse物化视图实现-是否存在一致性问题"><span>clickhouse物化视图实现,是否存在一致性问题</span></a></h2><h1 id="elasticsearch" tabindex="-1"><a class="header-anchor" href="#elasticsearch"><span>elasticsearch</span></a></h1><h2 id="主分片" tabindex="-1"><a class="header-anchor" href="#主分片"><span>主分片</span></a></h2><p>​ 主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作, bully 、raft算法选取主节点</p><h2 id="master节点选举" tabindex="-1"><a class="header-anchor" href="#master节点选举"><span>master节点选举</span></a></h2><p>从候选节点中选择 id 最小的节点作为主节点, bully算法</p><h2 id="分片分配" tabindex="-1"><a class="header-anchor" href="#分片分配"><span>分片分配</span></a></h2><p>​ master 节点进行分片数据分配. 通过将in-sync列表的分片遍历各个decider，如果有任一deny发生，则拒绝本次分配。决策结束之后可能会有多个节点，取第一个节点上的分片作为主分片。 (类似kafka 副本故障转移技术)</p><h1 id="java算法-常用函数" tabindex="-1"><a class="header-anchor" href="#java算法-常用函数"><span>java算法 常用函数</span></a></h1><h2 id="list删除元素" tabindex="-1"><a class="header-anchor" href="#list删除元素"><span>list删除元素</span></a></h2><p>arrays.remove();</p><h2 id="int-数组转化尽量用arraylist" tabindex="-1"><a class="header-anchor" href="#int-数组转化尽量用arraylist"><span>int[] 数组转化尽量用arraylist</span></a></h2><h2 id="二叉搜索树与双向链表-https-www-nowcoder-com-practice-947f6eb80d944a84850b0538bf0ec3a5-tpid-295-tqid-23253-ru-exam-oj-qru-ta-format-top101-question-ranking-sourceurl-2fexam-2foj" tabindex="-1"><a class="header-anchor" href="#二叉搜索树与双向链表-https-www-nowcoder-com-practice-947f6eb80d944a84850b0538bf0ec3a5-tpid-295-tqid-23253-ru-exam-oj-qru-ta-format-top101-question-ranking-sourceurl-2fexam-2foj"><span>二叉搜索树与双向链表:<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&amp;tqId=23253&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener noreferrer">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&amp;tqId=23253&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a></span></a></h2><h2 id="是否是二叉搜索树" tabindex="-1"><a class="header-anchor" href="#是否是二叉搜索树"><span>是否是二叉搜索树</span></a></h2><p>Array.copyOf({原数组},数组长度);</p><h1 id="_2023-07-10-乐信集团-一面" tabindex="-1"><a class="header-anchor" href="#_2023-07-10-乐信集团-一面"><span>2023-07-10 乐信集团- 一面</span></a></h1><h2 id="elasticsearch-数据删除之后会发生什么" tabindex="-1"><a class="header-anchor" href="#elasticsearch-数据删除之后会发生什么"><span>elasticsearch 数据删除之后会发生什么</span></a></h2><p>标记删除,还是会存在对应的数据, es内部维护线程进行段的合并。删除后可能导致性能不降反升, 可以调用es的merge 接口手动进行的段合并</p><h2 id="是否会存在大合并" tabindex="-1"><a class="header-anchor" href="#是否会存在大合并"><span>是否会存在大合并</span></a></h2><h2 id="es-数据查询变慢问题排查" tabindex="-1"><a class="header-anchor" href="#es-数据查询变慢问题排查"><span>es 数据查询变慢问题排查 :</span></a></h2><p>删除数据,导致cpu飙升, 可以手动进行es段的合并</p><h2 id="_2023-07-11-国泰产险-一面" tabindex="-1"><a class="header-anchor" href="#_2023-07-11-国泰产险-一面"><span>2023-07-11 国泰产险-一面</span></a></h2><p>压测如何进行</p><p>jmeter 还是自定义、</p><h1 id="_2023-07-11-华盛通-二面" tabindex="-1"><a class="header-anchor" href="#_2023-07-11-华盛通-二面"><span>2023-07-11 华盛通 二面</span></a></h1><h1 id="_2023-07-12-健康160一面" tabindex="-1"><a class="header-anchor" href="#_2023-07-12-健康160一面"><span>2023-07-12 健康160一面</span></a></h1><h2 id="ribbon负载均衡" tabindex="-1"><a class="header-anchor" href="#ribbon负载均衡"><span>ribbon负载均衡</span></a></h2><h2 id="限流" tabindex="-1"><a class="header-anchor" href="#限流"><span>限流</span></a></h2><p>​ sentinel限流</p><p>​ Guava Rate limit :基于令牌桶算法</p><p>本地限流: 每个节点分配一定的流量, 查询是判断是否流量是否控制范围内,若是, 正常执行, 否的话,拒绝, 每隔一段时间拉取对应的流量,</p><p>分布式限流: 针对并发比较小的情况</p><h2 id="tcc事务机制-事务悬挂问题" tabindex="-1"><a class="header-anchor" href="#tcc事务机制-事务悬挂问题"><span>TCC事务机制 ,事务悬挂问题</span></a></h2><p>tcc 三个阶段:</p><p>try</p><p>confirm</p><p>cancel</p><p>需要业务保证,幂等性、空回滚、事务悬挂问题</p><p>事务悬挂: 先try 、后cancel , try 后到达, 导致先进行了cancel ,try 资源被悬挂,解决方案 ,执行try的时候需要判断下是否先执行了cancel ,如果执行不用执行try了</p><h2 id="范型" tabindex="-1"><a class="header-anchor" href="#范型"><span>范型</span></a></h2><p>优势</p><ul><li>类型安全,可以在编译期进行类型擦出,及时发现类型安全问题</li><li>使用范型,可以编写更加通用的代码,提高代码的灵活性</li><li>使用时,可以避免频繁类型转换</li></ul><p>局限性:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>无法使用基本类型作为类型参数，例如List&lt;int&gt;是不允许的，需要使用包装类List&lt;Integer&gt;代替。</span></span>\n<span class="line"><span>无法创建具有泛型类型参数的数组，例如new T[]是不合法的，可以使用List&lt;T&gt;代替。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="elasticsearch有多少种查询方式" tabindex="-1"><a class="header-anchor" href="#elasticsearch有多少种查询方式"><span>elasticsearch有多少种查询方式</span></a></h2><p>xxx<br> term查询（精准查询）<br> math查询（分词匹配查询）<br> fuzzy查询（模糊查询）<br> wildcard(通配符查询)<br> bool查询（布尔查询）</p><p>分页查询</p><ul><li>from + size,分页限制1万,超过会报错</li><li>search after 利用实时有游标来帮我们解决实时滚动的问题。第一次搜索时需要指定 sort，并且保证值是唯一的，可以通过加入 _id 保证唯一性。缺点: 可以实时高效的进行分页查询，但是它只能做下一页这样的查询场景，不能随机的指定页数查询</li><li>scroll api 创建一个快照，有新的数据写入以后,无法被查到。每次查询后，输入上一次的 scroll_id。目前官方已经不推荐使用这个API了，使用<code>search_after</code>即可。</li></ul><h2 id="redis-list用途" tabindex="-1"><a class="header-anchor" href="#redis-list用途"><span>redis list用途</span></a></h2><h2 id="redis-重启如何恢复数据-rdb、aof" tabindex="-1"><a class="header-anchor" href="#redis-重启如何恢复数据-rdb、aof"><span>redis 重启如何恢复数据 (rdb、aof)</span></a></h2><p>​ 如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整</p><h2 id="redis-使用注意事项" tabindex="-1"><a class="header-anchor" href="#redis-使用注意事项"><span>redis 使用注意事项</span></a></h2><h2 id="kafka如何保证幂等性" tabindex="-1"><a class="header-anchor" href="#kafka如何保证幂等性"><span>kafka如何保证幂等性</span></a></h2><h2 id="创建线程的方式" tabindex="-1"><a class="header-anchor" href="#创建线程的方式"><span>创建线程的方式</span></a></h2><ul><li>继承thread</li><li>实现runnable接口</li><li>实现callable接口 , new FutrueTask({Callable接口实现})</li><li>通过线程池</li></ul><h1 id="_2023-07-13-盛业一面" tabindex="-1"><a class="header-anchor" href="#_2023-07-13-盛业一面"><span>2023-07-13 盛业一面</span></a></h1><p>500万数据多个数据组合查询,如何进行优化</p><p>大表数据字段变更</p><p>分布式锁 , 数据库实现分布式锁, 节点挂掉后, 锁会被释放掉吗?</p><h1 id="_2023-07-13-华润" tabindex="-1"><a class="header-anchor" href="#_2023-07-13-华润"><span>2023-07-13 华润</span></a></h1><p>http 常见请求头</p><p>跨域问题</p><p>sha256</p><p>final方法</p><h2 id="feign-注解" tabindex="-1"><a class="header-anchor" href="#feign-注解"><span>feign 注解</span></a></h2><p>​ @FeignClient @RequestMapping</p><p>docker compose 最佳实践</p><p>注册中心设计:</p><h1 id="_2023-07-13-after-ship-一面挂" tabindex="-1"><a class="header-anchor" href="#_2023-07-13-after-ship-一面挂"><span>2023-07-13 after-ship (一面挂)</span></a></h1><p>场景类设计题目、堆 问题 , 感觉都答的差不多, 面试官说可以过, 最终挂了, 不知道啥原因</p><h1 id="_2023-07-14-华盛hr面" tabindex="-1"><a class="header-anchor" href="#_2023-07-14-华盛hr面"><span>2023-07-14 华盛hr面</span></a></h1><h1 id="_2023-07-17-shein-一面-挂-30分钟左右" tabindex="-1"><a class="header-anchor" href="#_2023-07-17-shein-一面-挂-30分钟左右"><span>2023-07-17 shein - 一面(挂) 30分钟左右</span></a></h1><h2 id="young-gc-如何进行垃圾回收-频繁youngc-会有什么问题" tabindex="-1"><a class="header-anchor" href="#young-gc-如何进行垃圾回收-频繁youngc-会有什么问题"><span>young gc -如何进行垃圾回收 ,频繁youngc 会有什么问题</span></a></h2><p>younggc 采用复制算法, 频繁younggc cpu 会飙升</p><h2 id="kafka-消息堆积-如何解决" tabindex="-1"><a class="header-anchor" href="#kafka-消息堆积-如何解决"><span>kafka 消息堆积 ,如何解决</span></a></h2><p>调整消费者拉取数据量大小</p><p>调整提交时间间隔</p><p>消息异步化处理(提升消费速度,避免积压)</p><h2 id="reetranlock-、synchronized-除了实现方式还有甚么区别" tabindex="-1"><a class="header-anchor" href="#reetranlock-、synchronized-除了实现方式还有甚么区别"><span>reetranlock 、synchronized 除了实现方式还有甚么区别</span></a></h2><p>锁区别, 公平锁、 非公平锁</p><p>是否可中断 , 不可中断、可中断</p><p>手动加锁、释放 ,reentrantlock 需要在finally 里面手动释放锁, 否则会导致锁一致得不到释</p><p>condition 、wait 、notifyALL 区别</p><h2 id="主动缓存里面的key是什么" tabindex="-1"><a class="header-anchor" href="#主动缓存里面的key是什么"><span>主动缓存里面的key是什么</span></a></h2><p>接口 + 请求参数</p><h2 id="大key存储问题" tabindex="-1"><a class="header-anchor" href="#大key存储问题"><span>大key存储问题</span></a></h2><h2 id="线程池停止的方式" tabindex="-1"><a class="header-anchor" href="#线程池停止的方式"><span>线程池停止的方式</span></a></h2><ul><li>shutdown</li><li>shutdownnow</li><li>awaitTermination, 请求等待一段时间后</li></ul><h2 id="redis-集群模式如何感知节点变化" tabindex="-1"><a class="header-anchor" href="#redis-集群模式如何感知节点变化"><span>redis 集群模式如何感知节点变化</span></a></h2><ul><li>lecture 开起定时更新网络结构配置 和 感知节点故障后 惰性更新配置 , 更新集群对应的不可用刷新间隔</li><li>redission 可以自动感知集群拓扑变化</li></ul><h1 id="_2023-07-17-唯品会一面-1个小时" tabindex="-1"><a class="header-anchor" href="#_2023-07-17-唯品会一面-1个小时"><span>2023-07-17 唯品会一面 (1个小时)</span></a></h1><h2 id="redis-集群如何实现mget" tabindex="-1"><a class="header-anchor" href="#redis-集群如何实现mget"><span>redis 集群如何实现mget</span></a></h2><h2 id="二级缓存如何实现" tabindex="-1"><a class="header-anchor" href="#二级缓存如何实现"><span>二级缓存如何实现</span></a></h2><p>springcache 、caffine 、</p><p>利用redis的发布订阅模式更新本地缓存数据</p><p>caffeine-redis-sping-boot-starter</p><p>订阅db里面的数据,同步更新redis缓存, redis 中利用pub/sub机制更新本地缓存</p><h2 id="什么时候需要自定义类加载器" tabindex="-1"><a class="header-anchor" href="#什么时候需要自定义类加载器"><span>什么时候需要自定义类加载器</span></a></h2><p>tomcat 自定义类加载器, 可以隔离web服务下不同jar之间的版本, 每个web容器只加载相应版本的jar</p><h1 id="_2023-07-18-乐信二面-30分钟" tabindex="-1"><a class="header-anchor" href="#_2023-07-18-乐信二面-30分钟"><span>2023-07-18 乐信二面(30分钟)</span></a></h1><h2 id="数据库为什么推荐用自增id作为主键索引" tabindex="-1"><a class="header-anchor" href="#数据库为什么推荐用自增id作为主键索引"><span>数据库为什么推荐用自增id作为主键索引</span></a></h2><ul><li>如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</li><li>如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</li></ul><h2 id="身份证号码如何做索引、频繁更新" tabindex="-1"><a class="header-anchor" href="#身份证号码如何做索引、频繁更新"><span>身份证号码如何做索引、频繁更新</span></a></h2><p>识别身份证号的关键信息 、 hash取值后做索引、 冗余一个字段做更新</p><h2 id="epoll-边缘触发和水平触发" tabindex="-1"><a class="header-anchor" href="#epoll-边缘触发和水平触发"><span>epoll 边缘触发和水平触发</span></a></h2><p>zset linklist 如何保证性能不退化成链表, 有个随机数,插入节点的时候按照概率, 越少层概率越小. 使得层数尽可能的均匀</p><h2 id="innodb的四大特性" tabindex="-1"><a class="header-anchor" href="#innodb的四大特性"><span>innodb的四大特性</span></a></h2><ul><li>插入缓存</li><li>二次写</li><li>自适应哈希</li><li>预读</li></ul><h1 id="_2023-07-18-健康160二面" tabindex="-1"><a class="header-anchor" href="#_2023-07-18-健康160二面"><span>2023-07-18 健康160二面</span></a></h1><p>项目问题一个个问</p><p>如何确保微信id数据问题</p><h1 id="_2023-07-19-盛业二面-30分钟-估计没戏-最后过了" tabindex="-1"><a class="header-anchor" href="#_2023-07-19-盛业二面-30分钟-估计没戏-最后过了"><span>2023-07-19 -盛业二面 (30分钟 ,估计没戏-最后过了)</span></a></h1><h1 id="_2023-07-19-华润二面-1个小时" tabindex="-1"><a class="header-anchor" href="#_2023-07-19-华润二面-1个小时"><span>2023-07-19 华润二面(1个小时)</span></a></h1><p>如何保证分布式事务的一致性,设计一种通用方案 ,最终消息一致性</p><p>http各版本区别 , 最新到http3.0 web3.0, 基于udp</p><h1 id="_2023-07-20-富图一面" tabindex="-1"><a class="header-anchor" href="#_2023-07-20-富图一面"><span>2023-07-20 富图一面</span></a></h1><h2 id="四次挥手过程" tabindex="-1"><a class="header-anchor" href="#四次挥手过程"><span>四次挥手过程</span></a></h2><p>最有有个timewait的过程,防止ack失败的情况出现</p><h2 id="dns污染" tabindex="-1"><a class="header-anchor" href="#dns污染"><span>dns污染</span></a></h2><h2 id="dns劫持" tabindex="-1"><a class="header-anchor" href="#dns劫持"><span>dns劫持</span></a></h2><h2 id="dns泄漏" tabindex="-1"><a class="header-anchor" href="#dns泄漏"><span>dns泄漏</span></a></h2><h2 id="dns-解析过程" tabindex="-1"><a class="header-anchor" href="#dns-解析过程"><span>dns 解析过程 :</span></a></h2><ol><li>主机先向本地域名服务器进行递归查询</li><li>本地域名服务器采用迭代查询，向一个根域名服务器进行查询</li><li>根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址</li><li>本地域名服务器向顶级域名服务器进行查询</li><li>顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址</li><li>本地域名服务器向权限服务器进行查询</li><li>权限服务器告诉本地域名服务器所查询的主机的IP地址</li><li>本地域名服务器最后把查询结果告诉主机</li></ol><h2 id="backlog-全链接队列-somaxconnection" tabindex="-1"><a class="header-anchor" href="#backlog-全链接队列-somaxconnection"><span>backlog:全链接队列 , somaxconnection</span></a></h2><p>即全连接队列长度 = min(backlog, 内核参数 net.core.somaxconn)</p><p>队列满了容易出现丢包的情况发生</p><h2 id="增大-tcp-半连接队列和全连接队列的方式" tabindex="-1"><a class="header-anchor" href="#增大-tcp-半连接队列和全连接队列的方式"><span>增大 TCP 半连接队列和全连接队列的方式</span></a></h2><ul><li>增大 TCP 半连接队列的方式是增大 /proc/sys/net/ipv4/tcp_max_syn_backlog；</li><li>增大 TCP 全连接队列的方式是增大 listen() 函数中的 backlog；</li></ul><p>ss命令 可以查看全连接队列</p><p>如何防止syn攻击</p><ul><li>增大半连接队列；</li><li>开启 tcp_syncookies 功能</li><li>减少 SYN+ACK 重传次数</li></ul><h2 id="_502-错误排查" tabindex="-1"><a class="header-anchor" href="#_502-错误排查"><span>502 错误排查</span></a></h2><p>服务器作为网关, 请求上游得不到正常的返回</p><h1 id="_2023-07-21-健康160三面-40分钟左右" tabindex="-1"><a class="header-anchor" href="#_2023-07-21-健康160三面-40分钟左右"><span>2023-07-21 -健康160三面(40分钟左右)</span></a></h1><p>职业生涯规划, 整体状态不太好, 没有说明自己的远期规划是什么,后面需要特别准备下 , 尤其是ai 相关领域,</p><h1 id="_2023-07-21-阿里lazada-一面-1个小时" tabindex="-1"><a class="header-anchor" href="#_2023-07-21-阿里lazada-一面-1个小时"><span>2023-07-21 - 阿里lazada (一面-1个小时)</span></a></h1><p>一道算法题, 求完全二叉树的最后一个节点 , 面试官比较nice ,体验很好 ,没怎么问八股文</p><p>简单问了下threadlocal</p><p>java、 go 之间的不同</p><p>完全二叉树的最后一个节点.</p><h1 id="_2023-07-24-唯品会二面-45分钟-挂" tabindex="-1"><a class="header-anchor" href="#_2023-07-24-唯品会二面-45分钟-挂"><span>2023-07-24 唯品会二面(45分钟-挂)</span></a></h1><h2 id="索引的实现原理" tabindex="-1"><a class="header-anchor" href="#索引的实现原理"><span>索引的实现原理</span></a></h2><ul><li><p>MyISAM,非聚簇索引</p></li><li><p>innodb 聚簇索引,底层B+树</p></li></ul><h1 id="_2023-07-23-阿里lazada-二面-一个小时-要挂-面试官不按常理出牌-最后过了" tabindex="-1"><a class="header-anchor" href="#_2023-07-23-阿里lazada-二面-一个小时-要挂-面试官不按常理出牌-最后过了"><span>2023-07-23 阿里lazada 二面(一个小时-- 要挂,面试官不按常理出牌-最后过了)</span></a></h1><h2 id="数据库-groupby-如何进行优化" tabindex="-1"><a class="header-anchor" href="#数据库-groupby-如何进行优化"><span>数据库 groupby 如何进行优化</span></a></h2><p>原始groupby过程</p><ul><li>临时表(内存或者磁盘) , 走索引,本身自带去重操作,就不会使用临时表了</li><li>orderby 排序,filesort(内存,磁盘)</li></ul><p>优化</p><p>elasticsearch 有过哪些优化</p><ul><li>查询优化</li><li>插入优化</li><li>硬件配置优化</li><li>数据字段优化, 合理设计分词,合理使用缓存</li><li>服务端合理设置分片,refresh(默认1秒)、tranlog时间(默认5秒)</li></ul><h1 id="_2023-07-25-富图" tabindex="-1"><a class="header-anchor" href="#_2023-07-25-富图"><span>2023-07-25 - 富图</span></a></h1><h2 id="系统调用是什么" tabindex="-1"><a class="header-anchor" href="#系统调用是什么"><span>系统调用是什么</span></a></h2><h2 id="证书如何签名、如何保证安全" tabindex="-1"><a class="header-anchor" href="#证书如何签名、如何保证安全"><span>证书如何签名、如何保证安全</span></a></h2><p>ca机构办法证书会对证书信息进行签名, 签名后有私钥进行加密, 浏览器内置了主流ca的公钥,可以揭秘对应的签名,采用相同的签名算法看两次签名是否一致即可</p><h2 id="bio、nio区别-同步与异步的区别" tabindex="-1"><a class="header-anchor" href="#bio、nio区别-同步与异步的区别"><span>BIO、NIO区别, 同步与异步的区别</span></a></h2><h2 id="如何避免死锁问题" tabindex="-1"><a class="header-anchor" href="#如何避免死锁问题"><span>如何避免死锁问题</span></a></h2><h1 id="_2023-07-25-oppo-一面数据平台开发" tabindex="-1"><a class="header-anchor" href="#_2023-07-25-oppo-一面数据平台开发"><span>2023-07-25 - oppo 一面数据平台开发</span></a></h1><p>没咋准备 ,估计凉了 , 凉就凉吧 ,无所谓了</p><p>maven的几种依赖scope , compile 、test、runtime</p><p>spark 任务</p><p>jedis 常用的配置</p><p>ast解析</p><p>join优化</p><p>clickhouse 常用的引擎</p><p>clickhouse 建表语句,skiplist</p><h1 id="_2023-07-26-富图三面-35分钟左右概率题没有分析出来-要凉最后过了" tabindex="-1"><a class="header-anchor" href="#_2023-07-26-富图三面-35分钟左右概率题没有分析出来-要凉最后过了"><span>2023-07-26 富图三面(35分钟左右概率题没有分析出来,要凉最后过了)</span></a></h1><p>概率题: 硬币空杯子概率,交换,因为交换之后的概率是2/3</p><p>中文词检索: trie树</p><p>go cpu调度</p><p>go 内存分配机制</p><p>close-wait 如何处理</p><p>进程挂掉后 os层面的连接会如何处理</p><h1 id="_2023-07-26-小红书-一面1小时25分钟" tabindex="-1"><a class="header-anchor" href="#_2023-07-26-小红书-一面1小时25分钟"><span>2023-07-26 小红书(一面1小时25分钟)</span></a></h1><p>直接来个算法设计题(不怎么会,设计完我还是蒙圈的)</p><p>interface SmartCache {<br> String get(String key);<br> }<br> //不考虑set操作</p><p>1.如果key不为热点，则从DB获取<br> return getFromDB(key);<br> // getFromDB()无需代码实现</p><p>2.如果key为热点，则将DB数据缓存到本地的某个数据结构，优先从本地缓存读取</p><p>定义最近N秒内访问次数超过M的key为热点key（M和N是固定的常数）</p><h2 id="消息写入redis-如何避免热key问题" tabindex="-1"><a class="header-anchor" href="#消息写入redis-如何避免热key问题"><span>消息写入redis , 如何避免热key问题</span></a></h2><p>客户端规定时间批量写入</p><p>写入时给个随机数</p><p>mq 错峰写入(会有延迟)</p><h1 id="_2023-07-27-阿里lazada-三面" tabindex="-1"><a class="header-anchor" href="#_2023-07-27-阿里lazada-三面"><span>2023-07-27 阿里lazada 三面</span></a></h1><p>入账出账是什么意思</p><p>平台类型账号转账如何提高并发和实时性</p><h1 id="_2023-07-28-oppo二面-画像" tabindex="-1"><a class="header-anchor" href="#_2023-07-28-oppo二面-画像"><span>2023-07-28 - oppo二面(画像)</span></a></h1><h1 id="_2023-07-28-中国移动" tabindex="-1"><a class="header-anchor" href="#_2023-07-28-中国移动"><span>2023-07-28 - 中国移动</span></a></h1><p>围着项目问</p><h1 id="_2023-07-30-沃尔玛-一二面" tabindex="-1"><a class="header-anchor" href="#_2023-07-30-沃尔玛-一二面"><span>2023-07-30 沃尔玛(一二面)</span></a></h1><p>场景设计题 ,现有模型 ,然后根据模型进行对应的技术选型 ,</p><p>考虑一些常见的问题 ,例如流量、安全 等</p><h1 id="_2023-07-31-小红书二面-应该是凉了-过" tabindex="-1"><a class="header-anchor" href="#_2023-07-31-小红书二面-应该是凉了-过"><span>2023-07-31 小红书二面(应该是凉了-过)</span></a></h1><p>给了一个算法 , 移动非0元素到最左侧 , 出了个乌龙,交换元素没搞对</p><h1 id="_2023-08-01-无觅-二面" tabindex="-1"><a class="header-anchor" href="#_2023-08-01-无觅-二面"><span>2023-08-01 无觅-二面</span></a></h1><p>资源有限的情况下,如何提升资源利用率</p><h1 id="_2023-08-01-oppo-三面" tabindex="-1"><a class="header-anchor" href="#_2023-08-01-oppo-三面"><span>2023-08-01 oppo-三面</span></a></h1><p>没问问题</p><h1 id="_2023-08-01-字节一面" tabindex="-1"><a class="header-anchor" href="#_2023-08-01-字节一面"><span>2023-08-01- 字节一面</span></a></h1><p>redis 热key问题</p><h1 id="_2023-08-02-平安一面" tabindex="-1"><a class="header-anchor" href="#_2023-08-02-平安一面"><span>2023-08-02 平安一面</span></a></h1><p>项目面试</p><p>设计</p><p>交替打印问题</p><p>有哪些还没有被发掘的点</p><h1 id="_2023-08-03-shopee一面" tabindex="-1"><a class="header-anchor" href="#_2023-08-03-shopee一面"><span>2023-08-03 shopee一面</span></a></h1><p>实现单链表的快速排序</p><h1 id="_2023-08-08-荣耀三面四面" tabindex="-1"><a class="header-anchor" href="#_2023-08-08-荣耀三面四面"><span>2023-08-08 荣耀三面四面</span></a></h1><p>领域设计模式</p><p>按照领域进行设计,尽可能少的减少业务影响对代码的干扰</p><p>战术设计: 边界上下文、核心子域、通用子域、支撑子域,实体、值对象</p><p>领域事件</p><p>战术设计: 用户接口层、应用层、领域层、接口层</p><p>洋葱模型、六边形架构(各种防腐层、VO、DTO、DO转换)</p><h1 id="_2023-08-09-小红书三面" tabindex="-1"><a class="header-anchor" href="#_2023-08-09-小红书三面"><span>2023-08-09 小红书三面</span></a></h1><p>架构变更hc调整, 到三面 没有后续了, 估计招到人了 ,不推进后续流程了</p><h1 id="_2023-08-09-字节-45分钟" tabindex="-1"><a class="header-anchor" href="#_2023-08-09-字节-45分钟"><span>2023-08-09 字节(45分钟)</span></a></h1><p>数组最大容量</p><p>推荐算法,如何保证推荐不重复</p><h1 id="_2023-08-14-字节三面" tabindex="-1"><a class="header-anchor" href="#_2023-08-14-字节三面"><span>2023-08-14 -字节三面</span></a></h1><h2 id="项目qps-、tps-之类的-需要考虑面试者对项目的熟悉程度" tabindex="-1"><a class="header-anchor" href="#项目qps-、tps-之类的-需要考虑面试者对项目的熟悉程度"><span>项目qps 、tps 之类的,需要考虑面试者对项目的熟悉程度</span></a></h2><h2 id="设计一个停车场收费系统" tabindex="-1"><a class="header-anchor" href="#设计一个停车场收费系统"><span>设计一个停车场收费系统</span></a></h2>',244)]))}]]),r=JSON.parse('{"path":"/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html","title":"面试问题","lang":"zh-CN","frontmatter":{"title":"面试问题","description":"华盛通2023-07-07 一面 spring中的设计模式 Aop机制 面向切面变成, 基于jdk 动态代理和cglib动态代理实现, 可以为方法指定对应的切面 ,从而动态扩展方法功能 , 比如为远程方法调用增加日志、trace.等 jdk动态代理:运行时动态代理技术, 可以实现对接口的动态代理, 实现对象的invoactionhandler 来扩展原...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"ntom"}],["meta",{"property":"og:title","content":"面试问题"}],["meta",{"property":"og:description","content":"华盛通2023-07-07 一面 spring中的设计模式 Aop机制 面向切面变成, 基于jdk 动态代理和cglib动态代理实现, 可以为方法指定对应的切面 ,从而动态扩展方法功能 , 比如为远程方法调用增加日志、trace.等 jdk动态代理:运行时动态代理技术, 可以实现对接口的动态代理, 实现对象的invoactionhandler 来扩展原..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-23T14:28:54.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-23T14:28:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-23T14:28:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"notm\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"spring中的设计模式","slug":"spring中的设计模式","link":"#spring中的设计模式","children":[]},{"level":2,"title":"Aop机制","slug":"aop机制","link":"#aop机制","children":[]},{"level":2,"title":"kafka消息积压如何处理, 加消费者后rebalance如何解决分区重分配问题","slug":"kafka消息积压如何处理-加消费者后rebalance如何解决分区重分配问题","link":"#kafka消息积压如何处理-加消费者后rebalance如何解决分区重分配问题","children":[]},{"level":2,"title":"redis节点挂掉如何处理","slug":"redis节点挂掉如何处理","link":"#redis节点挂掉如何处理","children":[]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]},{"level":2,"title":"arraylist 、linklist插入数据时间复杂度、空间复杂度","slug":"arraylist-、linklist插入数据时间复杂度、空间复杂度","link":"#arraylist-、linklist插入数据时间复杂度、空间复杂度","children":[]},{"level":2,"title":"clickhouse物化视图实现,是否存在一致性问题","slug":"clickhouse物化视图实现-是否存在一致性问题","link":"#clickhouse物化视图实现-是否存在一致性问题","children":[]},{"level":2,"title":"主分片","slug":"主分片","link":"#主分片","children":[]},{"level":2,"title":"master节点选举","slug":"master节点选举","link":"#master节点选举","children":[]},{"level":2,"title":"分片分配","slug":"分片分配","link":"#分片分配","children":[]},{"level":2,"title":"list删除元素","slug":"list删除元素","link":"#list删除元素","children":[]},{"level":2,"title":"int[]  数组转化尽量用arraylist","slug":"int-数组转化尽量用arraylist","link":"#int-数组转化尽量用arraylist","children":[]},{"level":2,"title":"二叉搜索树与双向链表:https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tqId=23253&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj","slug":"二叉搜索树与双向链表-https-www-nowcoder-com-practice-947f6eb80d944a84850b0538bf0ec3a5-tpid-295-tqid-23253-ru-exam-oj-qru-ta-format-top101-question-ranking-sourceurl-2fexam-2foj","link":"#二叉搜索树与双向链表-https-www-nowcoder-com-practice-947f6eb80d944a84850b0538bf0ec3a5-tpid-295-tqid-23253-ru-exam-oj-qru-ta-format-top101-question-ranking-sourceurl-2fexam-2foj","children":[]},{"level":2,"title":"是否是二叉搜索树","slug":"是否是二叉搜索树","link":"#是否是二叉搜索树","children":[]},{"level":2,"title":"elasticsearch 数据删除之后会发生什么","slug":"elasticsearch-数据删除之后会发生什么","link":"#elasticsearch-数据删除之后会发生什么","children":[]},{"level":2,"title":"是否会存在大合并","slug":"是否会存在大合并","link":"#是否会存在大合并","children":[]},{"level":2,"title":"es 数据查询变慢问题排查 :","slug":"es-数据查询变慢问题排查","link":"#es-数据查询变慢问题排查","children":[]},{"level":2,"title":"2023-07-11 国泰产险-一面","slug":"_2023-07-11-国泰产险-一面","link":"#_2023-07-11-国泰产险-一面","children":[]},{"level":2,"title":"ribbon负载均衡","slug":"ribbon负载均衡","link":"#ribbon负载均衡","children":[]},{"level":2,"title":"限流","slug":"限流","link":"#限流","children":[]},{"level":2,"title":"TCC事务机制 ,事务悬挂问题","slug":"tcc事务机制-事务悬挂问题","link":"#tcc事务机制-事务悬挂问题","children":[]},{"level":2,"title":"范型","slug":"范型","link":"#范型","children":[]},{"level":2,"title":"elasticsearch有多少种查询方式","slug":"elasticsearch有多少种查询方式","link":"#elasticsearch有多少种查询方式","children":[]},{"level":2,"title":"redis list用途","slug":"redis-list用途","link":"#redis-list用途","children":[]},{"level":2,"title":"redis 重启如何恢复数据 (rdb、aof)","slug":"redis-重启如何恢复数据-rdb、aof","link":"#redis-重启如何恢复数据-rdb、aof","children":[]},{"level":2,"title":"redis 使用注意事项","slug":"redis-使用注意事项","link":"#redis-使用注意事项","children":[]},{"level":2,"title":"kafka如何保证幂等性","slug":"kafka如何保证幂等性","link":"#kafka如何保证幂等性","children":[]},{"level":2,"title":"创建线程的方式","slug":"创建线程的方式","link":"#创建线程的方式","children":[]},{"level":2,"title":"feign 注解","slug":"feign-注解","link":"#feign-注解","children":[]},{"level":2,"title":"young gc -如何进行垃圾回收 ,频繁youngc 会有什么问题","slug":"young-gc-如何进行垃圾回收-频繁youngc-会有什么问题","link":"#young-gc-如何进行垃圾回收-频繁youngc-会有什么问题","children":[]},{"level":2,"title":"kafka 消息堆积 ,如何解决","slug":"kafka-消息堆积-如何解决","link":"#kafka-消息堆积-如何解决","children":[]},{"level":2,"title":"reetranlock 、synchronized 除了实现方式还有甚么区别","slug":"reetranlock-、synchronized-除了实现方式还有甚么区别","link":"#reetranlock-、synchronized-除了实现方式还有甚么区别","children":[]},{"level":2,"title":"主动缓存里面的key是什么","slug":"主动缓存里面的key是什么","link":"#主动缓存里面的key是什么","children":[]},{"level":2,"title":"大key存储问题","slug":"大key存储问题","link":"#大key存储问题","children":[]},{"level":2,"title":"线程池停止的方式","slug":"线程池停止的方式","link":"#线程池停止的方式","children":[]},{"level":2,"title":"redis 集群模式如何感知节点变化","slug":"redis-集群模式如何感知节点变化","link":"#redis-集群模式如何感知节点变化","children":[]},{"level":2,"title":"redis 集群如何实现mget","slug":"redis-集群如何实现mget","link":"#redis-集群如何实现mget","children":[]},{"level":2,"title":"二级缓存如何实现","slug":"二级缓存如何实现","link":"#二级缓存如何实现","children":[]},{"level":2,"title":"什么时候需要自定义类加载器","slug":"什么时候需要自定义类加载器","link":"#什么时候需要自定义类加载器","children":[]},{"level":2,"title":"数据库为什么推荐用自增id作为主键索引","slug":"数据库为什么推荐用自增id作为主键索引","link":"#数据库为什么推荐用自增id作为主键索引","children":[]},{"level":2,"title":"身份证号码如何做索引、频繁更新","slug":"身份证号码如何做索引、频繁更新","link":"#身份证号码如何做索引、频繁更新","children":[]},{"level":2,"title":"epoll 边缘触发和水平触发","slug":"epoll-边缘触发和水平触发","link":"#epoll-边缘触发和水平触发","children":[]},{"level":2,"title":"innodb的四大特性","slug":"innodb的四大特性","link":"#innodb的四大特性","children":[]},{"level":2,"title":"四次挥手过程","slug":"四次挥手过程","link":"#四次挥手过程","children":[]},{"level":2,"title":"dns污染","slug":"dns污染","link":"#dns污染","children":[]},{"level":2,"title":"dns劫持","slug":"dns劫持","link":"#dns劫持","children":[]},{"level":2,"title":"dns泄漏","slug":"dns泄漏","link":"#dns泄漏","children":[]},{"level":2,"title":"dns 解析过程 :","slug":"dns-解析过程","link":"#dns-解析过程","children":[]},{"level":2,"title":"backlog:全链接队列 ,  somaxconnection","slug":"backlog-全链接队列-somaxconnection","link":"#backlog-全链接队列-somaxconnection","children":[]},{"level":2,"title":"增大 TCP 半连接队列和全连接队列的方式","slug":"增大-tcp-半连接队列和全连接队列的方式","link":"#增大-tcp-半连接队列和全连接队列的方式","children":[]},{"level":2,"title":"502 错误排查","slug":"_502-错误排查","link":"#_502-错误排查","children":[]},{"level":2,"title":"索引的实现原理","slug":"索引的实现原理","link":"#索引的实现原理","children":[]},{"level":2,"title":"数据库 groupby 如何进行优化","slug":"数据库-groupby-如何进行优化","link":"#数据库-groupby-如何进行优化","children":[]},{"level":2,"title":"系统调用是什么","slug":"系统调用是什么","link":"#系统调用是什么","children":[]},{"level":2,"title":"证书如何签名、如何保证安全","slug":"证书如何签名、如何保证安全","link":"#证书如何签名、如何保证安全","children":[]},{"level":2,"title":"BIO、NIO区别, 同步与异步的区别","slug":"bio、nio区别-同步与异步的区别","link":"#bio、nio区别-同步与异步的区别","children":[]},{"level":2,"title":"如何避免死锁问题","slug":"如何避免死锁问题","link":"#如何避免死锁问题","children":[]},{"level":2,"title":"消息写入redis , 如何避免热key问题","slug":"消息写入redis-如何避免热key问题","link":"#消息写入redis-如何避免热key问题","children":[]},{"level":2,"title":"项目qps 、tps 之类的,需要考虑面试者对项目的熟悉程度","slug":"项目qps-、tps-之类的-需要考虑面试者对项目的熟悉程度","link":"#项目qps-、tps-之类的-需要考虑面试者对项目的熟悉程度","children":[]},{"level":2,"title":"设计一个停车场收费系统","slug":"设计一个停车场收费系统","link":"#设计一个停车场收费系统","children":[]}],"git":{"createdTime":1734964134000,"updatedTime":1734964134000,"contributors":[{"name":"Yang Yang","username":"Yang Yang","email":"yangyang@YangdeMacBook-Air.local","commits":1,"url":"https://github.com/Yang Yang"}]},"readingTime":{"minutes":13.73,"words":4120},"filePathRelative":"其他/面试问题.md","localizedDate":"2024年12月23日","autoDesc":true}')},6262:(a,e)=>{e.A=(a,e)=>{const n=a.__vccOpts||a;for(const[a,i]of e)n[a]=i;return n}}}]);